### xv6第7章excersize
#### 第一题
当lk != &p->lock时，release(lk)可能会导致v进程进入wakeup操作，同时由于此时p->lock未使用，导致wakeup已经完成，但sleep操作未进行。
#### 第二题
exit和wait操作有两种顺序：
1. child exit -> parent wait
2. parent wait->child exit
考虑到管道的操作如果child是写端，parent是读端，如果把file close放在wait考虑情况1,child exit没有关闭文件，此时管道写端没有关闭并且写端没有输入，无法唤醒parent读端，parent sleep在read操作。在没有其他机制的情况下，parent将无法被唤醒。
#### 第三题
```c
void V(struct semaphore *s)
{
  acquire(&s->lock);
  s->count += 1;
  wakeup(s);	
  release(&s->lock);
}

void P(struct semaphore *s)
{
  while (s->count == 0)
    sleep(s);			
  acquire(&s->lock);
  s->count -= 1;
  release(&s->lock);
}
```
### xv6 uthread
1. 注意赋值sp寄存器时要从栈的高地址赋值
2. 注意ph fast的要求需要设置细粒度的锁来减少数据冲突
3. barrier中使用条件变量，条件满足时恢复bstat的状态
